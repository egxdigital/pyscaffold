"""
Pyscaffold Fragments

This module contains format strings used to load boilerplate code in the Pyscaffold application.

"""

pyscaffold_ascii = '\033[36m'  + r"""
                                         ___    ___      ___       __     
                                       /'___\ /'___\    /\_ \     /\ \    
 _____   __  __    ____   ___     __  /\ \__//\ \__/  __\//\ \    \_\ \   
/\ '__`\/\ \/\ \  /',__\ /'___\ /'__`\\ \ ,__\ \ ,__\/ __`\ \ \   /'_` \  
\ \ \L\ \ \ \_\ \/\__, `/\ \__//\ \L\.\\ \ \_/\ \ \_/\ \L\ \_\ \_/\ \L\ \ 
 \ \ ,__/\/`____ \/\____\ \____\ \__/.\_\ \_\  \ \_\\ \____/\____\ \___,_\
  \ \ \/  `/___/> \/___/ \/____/\/__/\/_/\/_/   \/_/ \/___/\/____/\/__,_ /
   \ \_\     /\___/                                                       
    \/_/     \/__/""" + '\033[0m'


PKG_CONFIG_PY = (
    "\"\"\"\n"
    "{ProjectName} Config\n"
    "\n"
    "This module contains configuration definitions for the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "import yaml\n"
    "from pathlib import Path\n"
    "\n"
    "class colors():\n"
    "    HEADER     = '\033[95m'\n"
    "    OKBLUE     = '\033[94m'\n"
    "    OKCYAN     = '\033[96m'\n"
    "    OKGREEN    = '\033[92m'\n"
    "    WARNING    = '\033[93m'\n"
    "    FAIL       = '\033[91m'\n"
    "    ENDC       = '\033[0m'\n"
    "    BOLD       = '\033[1m'\n"
    "    UNDERLINE  = '\033[4m'\n"
    "\n"    
    "class Config():\n"
    "    def __init__(self, config_path=None):\n"
    "        self.settings = {{}}\n"
    "        if config_path is None:\n"
    "            config_path = Path(__file__).resolve().parent.parent / 'config.yaml'\n"
    "        self.load_from_file(config_path)\n"
    "\n"
    "    def load_from_file(self, config_path):\n"
    "        \"\"\"\n"
    "        Load configuration settings from a YAML file.\n"
            
    "        Args:\n"
    "            config_path (str): Path to the YAML configuration file.\n"
    "        \"\"\"\n"
    "        with open(config_path, 'r') as file:\n"
    "            self.settings = yaml.safe_load(file)\n"
    "\n"
    "    def get(self, key, default=None):\n"
    "        \"\"\"\n"
    "        Retrieve a configuration value by its key.\n"
    "\n"            
    "        Args:\n"
    "            key (str): The key to look up in the configuration.\n"
    "            default: The default value to return if the key is not found.\n"
    "\n"            
    "        Returns:\n"
    "            The value associated with the key, or the default value.\n"
    "        \"\"\"\n"
    "        keys = key.split('.')\n"
    "        value = self.settings\n"
    "        for k in keys:\n"
    "            if isinstance(value, dict):\n"
    "                value = value.get(k, default)\n"
    "            else:\n"
    "                return default\n"
    "        return value\n"
    "\n"
    "    def add_setting(self, name, **kwargs):\n"
    "        \"\"\"\n"
    "        Add a new setting to the configuration.\n"
    "\n"            
    "        Args:\n"
    "            name (str): The name of the new setting.\n"
    "            kwargs: The key-value pairs for the new setting.\n"
    "\n"            
    "        Returns:\n"
    "            self\n"
    "        \"\"\"\n"
    "        self.settings[name] = kwargs\n"
    "        return self\n"
    "\n"
    "    def update_setting(self, name, **kwargs):\n"
    "        \"\"\"\n"
    "        Update an existing setting in the configuration.\n"
    "\n"            
    "        Args:\n"
    "            name (str): The name of the setting to update.\n"
    "            kwargs: The key-value pairs to update the setting with.\n"
    "\n"            
    "        Returns:\n"
    "            self\n"
    "        \"\"\"\n"
    "        if name in self.settings:\n"
    "            self.settings[name].update(kwargs)\n"
    "        else:\n"
    "            self.settings[name] = kwargs\n"
    "        return self\n"
    "\n"
    "    def display(self):\n"
    "        \"\"\"\n"
    "        Display all configuration settings.\n"
    "        \"\"\"\n"
    "        from pprint import pprint\n"
    "        pprint(self.settings)\n"
    "\n"        
    "    def get_projects_directory_path(self) -> Path:\n"
    "        \"\"\"\n"
    "        Retrieve the absolute path to the global projects directory.\n"
    "\n"
    "        Returns:\n"
    "            Path: The resolved projects directory pathname.\n"
    "\n"            
    "        Raises:\n"
    "            ValueError: If the resolved path does not exist.\n"
    "        \"\"\"\n"
    "        path = Path(self.get('locations.PROJECTS'))\n"
    "\n"
    "        if not path.exists():\n"
    "            raise ValueError('Projects directory has not been set.')\n"
    "\n"            
    "        return path\n"
    "\n"
    "    def get_tests_directory_path(self, abs=False) -> Path:\n"   
    "        \"\"\"\n"
    "        Retrieve the path to the test projects directory.\n"
    "\n"
    "        Args:\n"
    "            abs (bool): If True, returns the absolute path.\n"
    "\n"
    "        Returns:\n"
    "            Path: The resolved test projects directory pathname.\n"
    "\n"            
    "        Raises:\n"
    "            ValueError: If the resolved path does not exist.\n"
    "        \"\"\"\n"
    "        path = Path(self.get('locations.TEST_PROJECTS'))\n"
    "        if abs:\n"
    "            path = Path(__file__).resolve().parent.parent / path\n"
    "\n"            
    "        if not path.exists():\n"
    "            raise ValueError('Tests directory does not exist.')\n"
    "\n"            
    "        return path\n"
)

PKG_HELPERS_PY = (
    "\"\"\"\n"
    "{ProjectName} Helpers\n"
    "\n"
    "This module contains helper function definitions for the {ProjectName} application.\n"
    "\"\"\"\n"
)

PKG_UTILS_PY = (
    "\"\"\"\n"
    "{ProjectName} Utilities\n"
    "\n"
    "This module contains utility function definitions for the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "import argarse\n"
    "\n"
    "def do_something(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def do_something_else(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def do_another_thing(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def preprocess_arguments(args: argparse.Namespace) -> None:\n"
    "    do_something(args)\n"
    "    do_something_else(args)\n"
    "    do_another_thing(args)\n"
    "\n"
)

PKG_MODULE_PY = (
    "\"\"\"\n"
    "{ProjectName}\n"
    "\n"
    "This module contains the class definition for the {ProjectName} class.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "class {ProjectName}():\n"
    "    @staticmethod\n"
    "    def subcommand1(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
    "    @staticmethod\n"
    "    def subcommand2(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
    "    @staticmethod\n"
    "    def subcommand3(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
)

PKG_ARG_PARSER_PY = (
    "\"\"\"\n"
    "{ProjectName} Argument Parser\n"
    "\n"
    "This module contains the argument parsing functionality of the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "import argparse\n"
    "from {packagename}.config import colors\n"
    "\n"
    "def create_parser():\n"
    "    parser = argparse.ArgumentParser(\n"
    "        prog='{packagename}',\n"
    "        fromfile_prefix_chars='@',\n"
    "        usage=(\n"
    "            f'{{colors.BOLD}}%(prog)s{{colors.ENDC}} '\n"
    "            f'{{colors.OKCYAN}}COMMAND{{colors.ENDC}} '\n"
    "            f'{{colors.WARNING}}[{{colors.ENDC}}OPTION{{colors.WARNING}}]{{colors.ENDC}} '\n"
    "            f'{{colors.OKBLUE}}PROJECTA{{colors.ENDC}} '\n"
    "            f'{{colors.WARNING}}[{{colors.ENDC}}{{colors.OKBLUE}}PROJECTB{{colors.ENDC}} ...{{colors.WARNING}}]{{colors.ENDC}}'\n"
    "        ),\n"
    "        formatter_class=argparse.RawDescriptionHelpFormatter,\n"
    "    )\n"
    "\n"    
    "    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')\n"
    "\n"      
    "    subparsers = parser.add_subparsers(dest='command', required=True)\n"
    "\n"
    "    subcommand_1_parser = subparsers.add_parser('list', help='List projects')\n"
    "    subcommand_1_parser.add_argument('-d', '--destination', type=str, help='Valid directory pathname as project directory')\n"
    "\n"
    "    subcommand_2_parser = subparsers.add_parser('start', help='Start a project')\n"
    "    subcommand_2_parser.add_argument('project_names', nargs='+', type=str, help='Name(s) of the project to start')\n"
    "\n"
    "    subcommand_3_parser = subparsers.add_parser('resume', help='Resume a project')\n"
    "    subcommand_3_parser.add_argument('project_name', type=str, help='Name of the project to resume')\n"
    "\n"  
    "    return parser\n"
)

PKG_MAIN_PY = (
    "\"\"\"\n"
    "Entry point for the {ProjectName} application.\n"
    "\n"    
    "This script serves as the main entry point for the {ProjectName} application. \n"
    "It initializes the application, processes command-line arguments, and \n"
    "starts the main functionality of the project.\n"
    "\n"
    "Usage:\n"
    "    {packagename} subcommand1 <argument> [options]\n"
    "    {packagename} subcommand2 <argument> [options]\n"
    "    {packagename} subcommand3 <argument> [options]\n"
    "\n"
    "Arguments:\n"
    "    -h, --help      Show this help message and exit.\n"
    "    -v, --version   Show the version of the application and exit.\n"
    "\n"
    "Functions:\n"
    "    main()      The main function that initializes and runs the application.\n"
    "    execute()   The function that invokes the subcommand passed to the application.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "from {packagename}.{packagename} import {ProjectName}\n"
    "from {packagename}.arg_parser import create_parser\n"
    "from {packagename}.utils import preprocess_arguments\n"
    "\n"
    "SUBCOMMANDS = {{\n"
    "    'subcommand1': {ProjectName}.subcommand1,\n"
    "    'subcommand2': {ProjectName}.subcommand2,\n"
    "    'subcommand3': {ProjectName}.subcommand3\n"
    "}}\n"
    "\n"
    "def execute(command, args):\n"
    "    func = SUBCOMMANDS[command]\n"
    "    try:\n"
    "        result = func(**vars(args))\n"
    "    except Exception as e:\n"
    "        print(f'Error: {{e}}')\n"
    "    else:\n"
    "        return result\n"
    "\n"
    "def main():\n"
    "    parser = create_parser()\n"
    "    args = parser.parse_args()\n"
    "    preprocess_arguments(args)\n"
    "    execute(args.command, args)\n"
    "\n"
)

TEST_CONFIG_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Configuration\n"
    "\n"
    "This module contains tests for the {ProjectName} configuration settings.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "import pytest\n"
    "from {packagename}.config import Config\n"
    "\n"
    "sample_config = \"\"\"\n"
    "collection:\n"
    "  VAR1: value1\n"
    "  VAR2: value2\n"
    "\"\"\"\n"
    "\n"
    "@pytest.fixture(scope='module')\n"
    "def config_file(tmp_path_factory):\n"
    "    config_path = tmp_path_factory.mktemp('data') / 'config.yaml'\n"
    "    with open(config_path, 'w') as f:\n"
    "        f.write(sample_config)\n"
    "    return config_path\n"
    "\n"    
    "def test_load_from_file(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('collection.VAR1') == value1\n"
    "    assert config.get('collection.VAR2') == value2\n"
    "\n"
    "def test_get_existing_key(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('collection.VAR1') == value1\n"
    "\n"
    "def test_get_non_existing_key(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('non.existing.key') is None\n"
    "    assert config.get('non.existing.key', 'default_value') == 'default_value'\n"
    "\n"
    "def test_add_setting(config_file):\n"
    "    config = Config(config_file)\n"
    "    config.add_setting('new_setting', key1='value1', key2='value2')\n"
    "    assert config.get('new_setting.key1') == 'value1'\n"
    "    assert config.get('new_setting.key2') == 'value2'\n"
    "\n"
    "def test_update_setting(config_file):\n"
    "    config = Config(config_file)\n"
    "    config.add_setting('update_setting', key1='value1')\n"
    "    config.update_setting('update_setting', key1='new_value', key2='value2')\n"
    "    assert config.get('update_setting.key1') == 'new_value'\n"
    "    assert config.get('update_setting.key2') == 'value2'\n"
)

TEST_HELPERS_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Helpers\n"
    "\n"
    "This module contains tests for the {ProjectName} helper functions.\n"
    "\n"
    "\"\"\"\n"
    "import pytest\n"
    "from {packagename}.helpers import * # Use explicit imports\n"
)

TEST_UTILS_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Utilities\n"
    "\n"
    "This module contains tests for the {ProjectName} utility functions.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "from pathlib import Path\n"
    "from argparse import Namespace\n"
    "\n"
    "import pytest\n"
    "\n"
    "from test_project.config import Config\n"
    "from test_project.utils import *\n"
    "\n"
    "@pytest.fixture(scope='function')\n"
    "def setup_and_teardown():\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "    Path(dummy_dir).mkdir(parents=True, exist_ok=True)\n"
    "\n"
    "    yield dummy_dir, config\n"
    "\n"
    "    for item in dummy_dir.iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "def test_do_something():\n"
    "    pass\n"
    "\n"
    "def test_do_something_else():\n"
    "    pass\n"
    "\n"
    "def test_do_another_thing():\n"
    "    pass\n"
    "\n"
    "def test_preprocess_arguments():\n"
    "    pass\n"
)

TEST_PACKAGE_MODULE_PY = (
    "\"\"\"\n"
    "{ProjectName} Tests\n"
    "\n"
    "This module contains tests for the {ProjectName} class.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "\n"
    "import pytest\n"
    "\n"
    "from test_project.config import Config\n"
    "from test_project.{packagename} import {ProjectName}\n"
    "\n"
    "@pytest.fixture(scope='function')\n"
    "def setup_and_teardown():\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "\n"
    "    yield dummy_projects_dir, config\n"
    "\n"
    "    for item in dummy_dir.iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "def test_subcommand1(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand1 == True\n"
    "\n"
    "def test_subcommand2(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand2 == True\n"
    "\n"
    "def test_subcommand3(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand3 == True\n"
    "\n"
)

TEST_CLI_PY = (
    "\"\"\"\n"
    "{ProjectName} Test CLI\n"
    "\n"
    "This module contains tests for the {ProjectName} CLI.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "import subprocess\n"
    "from pathlib import Path\n"
    "\n"
    "import pytest\n"
    "\n"
    "from {packagename}.config import Config\n"
    "\n"
    "@pytest.fixture(scope='function', autouse=True)\n"
    "def setup_and_teardown():\n"
    "    # Setup: Ensure the test directory exists\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "    Path(dummy_dir).mkdir(parents=True, exist_ok=True)\n"
    "\n"        
    "    yield dummy_dir\n"
    "\n"        
    "    # Teardown: Clean up the test directory\n"
    "    for item in Path(dummy_dir).iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_cli_help(script_runner):\n"
    "    result = script_runner.run(['{packagename}', '--help'])\n"
    "    assert result.success\n"
    "    assert 'usage' in result.stdout\n"
    "    assert result.stderr == ''\n"
    "\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_cli_version(script_runner):\n"
    "    result = script_runner.run(['{packagename}', '--version'])\n"
    "    assert result.success\n"
    "    assert 0.1.0' in result.stdout  # Adjust based on your actual version\n"
    "    assert result.stderr == ''\n"
    "\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_subcommand1(script_runner, setup_and_teardown):\n"
    "    dummy_projects_dir = setup_and_teardown\n"
    "    ret = script_runner.run(['{packagename}', 'subcommand1', 'arg1', '--option1', optval])\n"
    "    assert ret.success\n"    
)
