"""Fragments

This module contains format strings used to load boilerplate code in the Pyscaffold program.
"""

pyscaffold_ascii = '\033[36m'  + r"""
                                         ___    ___      ___       __     
                                       /'___\ /'___\    /\_ \     /\ \    
 _____   __  __    ____   ___     __  /\ \__//\ \__/  __\//\ \    \_\ \   
/\ '__`\/\ \/\ \  /',__\ /'___\ /'__`\\ \ ,__\ \ ,__\/ __`\ \ \   /'_` \  
\ \ \L\ \ \ \_\ \/\__, `/\ \__//\ \L\.\\ \ \_/\ \ \_/\ \L\ \_\ \_/\ \L\ \ 
 \ \ ,__/\/`____ \/\____\ \____\ \__/.\_\ \_\  \ \_\\ \____/\____\ \___,_\
  \ \ \/  `/___/> \/___/ \/____/\/__/\/_/\/_/   \/_/ \/___/\/____/\/__,_ /
   \ \_\     /\___/                                                       
    \/_/     \/__/""" + '\033[0m'


config_py = (
    "\"\"\"{Project} Config\n"
    "\n"
    "This module contains the config definitions for the {Project} program.\n"
    "\"\"\"\n"
    "from pathlib import Path, PurePath\n"
    "\n"
    "ROOT=Path(__file__).resolve().parent.parent\n"
    "PKG = Path(__file__).resolve().parent\n"
    "DATA=Path(PurePath(ROOT, 'data'))\n"
    "STATIC=Path(PurePath(ROOT, 'static'))\n"
    "TESTS=Path(PurePath(ROOT, 'tests'))\n"
    "TEST_DATA=Path(PurePath(TESTS, 'data'))\n"
    "\n"
    "class ERROR():\n"
    "    bad_command ='invalid command!'\n"
    "    bad_directory ='invalid destination directory!'\n"
    "    bad_file ='invalid input file!'\n"
    "\n"
    "class colors():\n"
    "    HEADER ='\\033[95m'\n"
    "    OKBLUE ='\\033[94m'\n"
    "    OKCYAN ='\\033[96m'\n"
    "    OKGREEN ='\\033[92m'\n"
    "    WARNING ='\\033[93m'\n"
    "    FAIL ='\\033[91m'\n"
    "    ENDC ='\\033[0m'\n"
    "    BOLD ='\\033[1m'\n"
    "    UNDERLINE ='\\033[4m'\n"
)

setup_py = (
    "\"\"\"{Project} Setup\n"
    "\n"
    "This module contains the setuptools.setup() definition for the {Project} program.\n"
    "Usage\n"
    "    deactivate (if using virtualenv)\n"
    "    ./install\n"
    "\"\"\"\n"
    "import os\n"
    "from pathlib import Path, PurePath\n"
    "from setuptools import setup, find_packages\n"
    "\n"
    "root=Path(__file__).resolve().parent\n"
    "requirements_txt=Path(PurePath(root, 'requirements.txt'))\n"
    "\n"
    "def read_requirements_file(fd):\n"
    "    res=[]\n"
    "    if Path(fd).is_file():\n"
    "        with open(fd, 'r') as reader:\n"
    "            res +=[lin.strip('{newline}')\n"
    "                    for lin in reader.readlines() if '#' not in lin]\n"
    "    return res\n"
    "\n"
    "with open('README.md', 'r') as fh:\n"
    "    long_description=fh.read()\n"
    "\n"
    "requirements=read_requirements_file(requirements_txt)\n"
    "\n"
    "setup(\n"
    "    name='{Project}',\n"
    "    version='1.0.0',\n"
    "    author='Emille Giddings',\n"
    "    author_email='emilledigital@gmail.com',\n"
    "    description='<enter description here>',\n"
    "    long_description=long_description,\n"
    "    long_description_content_type='text/markdown',\n"
    "    url='',\n"
    "    install_requires=requirements,\n"
    "    packages=find_packages(),\n"
    "    package_data={{'': ['', '']}},\n"
    "    entry_points={{\n"
    "        'console_scripts': ['{project}={project}.__main__:main']\n"
    "    }},\n"
    "    tests_require=[''],\n"
    "    classifiers=[\n"
    "        'Programming Language :: Python :: 3',\n"
    "        'License :: OSI Approved :: MIT License',\n"
    "        'Operating System :: OS Independent',\n"
    "    ],\n"
    "    python_requires='>={version}',\n"
    "    setup_requires=[\n"
    "    'setuptools>=42',\n"
    "    'wheel',\n"
    "    'setuptools_scm>=3.4'\n"
    "    ],\n"
    ")"
)

readme_md = (
    "# {project}"
)

innerpkg_main_py = (
    "\"\"\"{Project} Main\n"
    "\n"
    "This module contains the entry point code for the {Project} program.\n"
    "\"\"\"\n"
    "\n"
    "from {project}.{project} import main\n"
    "\n"
    "\n"
    "if __name__ == '__main__':\n"
    "    main()"
)

innermodule_py = (
    "\"\"\"{Project}\n"
    "\n"
    "This module contains the main function definitions for the {Project} program.\n"
    "\"\"\"\n"
    "import argparse\n"
    "from {project}.config import *\n"
    "from {project}.helpers import *\n"
    "\n"
    "class {Project}():\n"
    "    def __init__(self, parser, options):\n"
    "        self.valid_commands = [\n"
    "            \n"
    "        ]\n"
    "\n"
    "        self.valid_flags = [\n"
    "            \n"
    "        ]\n"
    "\n"
    "        self.parser = parser\n"
    "        self.options = options\n"
    "        self.command = ''\n"
    "\n"
    "        self.validate_command()\n"
    "\n"
    "    def __str__(self):\n"
    "        return (\n"
    "            'command: {{}}\\n'\n"
    "            'options: {{}}\\n'\n"
    "        ).format(\n"
    "            self.command,\n"
    "            self.options\n"
    "        )\n"
    "\n"
    "    def validate_command(self):\n"
    "        if self.options['commands'][0] not in self.valid_commands:\n"
    "            self.parser.error('bad command!')\n"
    "        self.command=self.options['commands'][0]\n"
    "\n"
    "def main():\n"
    "    parser = argparse.ArgumentParser(\n"
    "        prog='{project}',\n"
    "        fromfile_prefix_chars='@',\n"
    "        usage='{project} [options] <command> <arg1>',\n"
    "        description='<desc>',\n"
    "        epilog='Build it!')\n"
    "\n"
    "    # Add arguments here\n"
    "\n"
    "    parser.add_argument('-d', '--detail',\n"
    "                           action='store',\n"
    "                           type=str,\n"
    "                           required=False,\n"
    "                           help='modifies something')\n"
    "    parser.add_argument('commands',\n"
    "                           nargs='+',\n"
    "                           help=\"use a command eg. init or start\")\n"
    "\n"
    "    args = parser.parse_args()\n"
    "\n"
    "    options = vars(args)\n"
    "\n"
    "    {project} = {Project}(parser, options)"
)

innerpkg_helper_py = (
    "\"\"\"{Project} Helpers\n"
    "\n"
    "This module contains the helper function definitions for the {Project} program.\n"
    "\"\"\"\n"
    "from {project}.config import *"
)

test_helpers_py = (
    "\"\"\"{Project} Test Helpers\n"
    "\n"
    "This module contains the test case for the {Project} helpers module.\n"
    "\n"
    "Usage\n"
    "    python -m unittest tests.test_helpers\n"
    "\"\"\"\n"
    "import unittest\n"
    "from {project}.config import *\n"
    "from {project}.helpers import *\n"
    "\n"
    "class {Project}HelpersTest(unittest.TestCase):\n"
    "    def setUp(self):\n"
    "        pass\n"
    "\n"
    "\n"
    "    def tearDown(self):\n"
    "        pass\n"
    "\n"
    "\n"
    "if __name__ == '__main__':\n"
    "   unittest.main()"
)

test_project_py = (
    "\"\"\"Test {Project}\n"
    "\n"
    "This module contains the test case for the {Project} program.\n"
    "\n"
    "Usage\n"
    "    python -m unittest tests.test_{project}\n"
    "\"\"\"\n"
    "import unittest\n"
    "import argparse\n"
    "\n"
    "from {project}.config import *\n"
    "from {project}.helpers import *\n"
    "from {project}.{project} import *\n"
    "\n"
    "\n"
    "class {Project}Test(unittest.TestCase):\n"
    "    def setUp(self):\n"
    "        parser = argparse.ArgumentParser(\n"
    "            prog='{project}',\n"
    "            fromfile_prefix_chars='@',\n"
    "            usage='{project} [options] <command> <arg1>',\n"
    "            description='<desc>',\n"
    "            epilog='Build it!')\n"
    "\n"
    "        parser.add_argument('-d', '--detail',\n"
    "                       action='store',\n"
    "                       type=str,\n"
    "                       required=False,\n"
    "                       help='modifies something')\n"
    "        parser.add_argument('commands',\n"
    "                       nargs='+',\n"
    "                       help=\"use a command eg. init or start\")\n"
    "\n"
    "        self.parser = parser\n"
    "\n"
    "        def run_command(command: argparse.Namespace):\n"
    "            args = command\n"
    "            options = vars(args)\n"
    "            {project} = {Project}(self.parser, options)\n"
    "            return {project}\n"
    "\n"
    "        self.run_command = run_command\n"
    "\n"
    "    def tearDown(self):\n"
    "        pass\n"
    "\n"
    "    def test_{project}_command(self):\n"
    "        command = argparse.Namespace(\n"
    "            commands=['do', 'argument']\n"
    "        )\n"
    "        {project} = self.run_command(command)\n"
    "\n"
    "\n"
    "if __name__ == '__main__':\n"
    "    unittest.main()"
)
