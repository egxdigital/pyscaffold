"""
Pyscaffold Fragments

This module contains format strings used to load boilerplate code in the Pyscaffold application.

"""

pyscaffold_ascii = '\033[36m'  + r"""
                                         ___    ___      ___       __     
                                       /'___\ /'___\    /\_ \     /\ \    
 _____   __  __    ____   ___     __  /\ \__//\ \__/  __\//\ \    \_\ \   
/\ '__`\/\ \/\ \  /',__\ /'___\ /'__`\\ \ ,__\ \ ,__\/ __`\ \ \   /'_` \  
\ \ \L\ \ \ \_\ \/\__, `/\ \__//\ \L\.\\ \ \_/\ \ \_/\ \L\ \_\ \_/\ \L\ \ 
 \ \ ,__/\/`____ \/\____\ \____\ \__/.\_\ \_\  \ \_\\ \____/\____\ \___,_\
  \ \ \/  `/___/> \/___/ \/____/\/__/\/_/\/_/   \/_/ \/___/\/____/\/__,_ /
   \ \_\     /\___/                                                       
    \/_/     \/__/""" + '\033[0m'


PKG_CONFIG_PY = (
    "\"\"\"\n"
    "{ProjectName} Config\n"
    "\n"
    "This module contains configuration definitions for the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "import yaml\n"
    "from pathlib import Path\n"
    "\n"
    "class colors():\n"
    "    HEADER     = '\\033[95m'\n"
    "    OKBLUE     = '\\033[94m'\n"
    "    OKCYAN     = '\\033[96m'\n"
    "    OKGREEN    = '\\033[92m'\n"
    "    WARNING    = '\\033[93m'\n"
    "    FAIL       = '\\033[91m'\n"
    "    ENDC       = '\\033[0m'\n"
    "    BOLD       = '\\033[1m'\n"
    "    UNDERLINE  = '\\033[4m'\n"
    "\n"    
    "class Config():\n"
    "    def __init__(self, config_path=None):\n"
    "        self.settings = {{}}\n"
    "        if config_path is None:\n"
    "            config_path = Path(__file__).resolve().parent.parent / 'config.yaml'\n"
    "        self.load_from_file(config_path)\n"
    "\n"
    "    def load_from_file(self, config_path):\n"
    "        \"\"\"\n"
    "        Load configuration settings from a YAML file.\n"
            
    "        Args:\n"
    "            config_path (str): Path to the YAML configuration file.\n"
    "        \"\"\"\n"
    "        with open(config_path, 'r') as file:\n"
    "            self.settings = yaml.safe_load(file)\n"
    "\n"
    "    def get(self, key, default=None):\n"
    "        \"\"\"\n"
    "        Retrieve a configuration value by its key.\n"
    "\n"            
    "        Args:\n"
    "            key (str): The key to look up in the configuration.\n"
    "            default: The default value to return if the key is not found.\n"
    "\n"            
    "        Returns:\n"
    "            The value associated with the key, or the default value.\n"
    "        \"\"\"\n"
    "        keys = key.split('.')\n"
    "        value = self.settings\n"
    "        for k in keys:\n"
    "            if isinstance(value, dict):\n"
    "                value = value.get(k, default)\n"
    "            else:\n"
    "                return default\n"
    "        return value\n"
    "\n"
    "    def add_setting(self, name, **kwargs):\n"
    "        \"\"\"\n"
    "        Add a new setting to the configuration.\n"
    "\n"            
    "        Args:\n"
    "            name (str): The name of the new setting.\n"
    "            kwargs: The key-value pairs for the new setting.\n"
    "\n"            
    "        Returns:\n"
    "            self\n"
    "        \"\"\"\n"
    "        self.settings[name] = kwargs\n"
    "        return self\n"
    "\n"
    "    def update_setting(self, name, **kwargs):\n"
    "        \"\"\"\n"
    "        Update an existing setting in the configuration.\n"
    "\n"            
    "        Args:\n"
    "            name (str): The name of the setting to update.\n"
    "            kwargs: The key-value pairs to update the setting with.\n"
    "\n"            
    "        Returns:\n"
    "            self\n"
    "        \"\"\"\n"
    "        if name in self.settings:\n"
    "            self.settings[name].update(kwargs)\n"
    "        else:\n"
    "            self.settings[name] = kwargs\n"
    "        return self\n"
    "\n"
    "    def display(self):\n"
    "        \"\"\"\n"
    "        Display all configuration settings.\n"
    "        \"\"\"\n"
    "        from pprint import pprint\n"
    "        pprint(self.settings)\n"
    "\n"
    "    def get_tests_directory_path(self, abs=False) -> Path:\n"   
    "        \"\"\"\n"
    "        Retrieve the path to the test projects directory.\n"
    "\n"
    "        Args:\n"
    "            abs (bool): If True, returns the absolute path.\n"
    "\n"
    "        Returns:\n"
    "            Path: The resolved test projects directory pathname.\n"
    "\n"            
    "        Raises:\n"
    "            ValueError: If the resolved path does not exist.\n"
    "        \"\"\"\n"
    "        path = Path(self.get('settings.DUMMY_DIR'))\n"
    "        if abs:\n"
    "            path = Path(__file__).resolve().parent.parent / path\n"
    "\n"            
    "        if not path.exists():\n"
    "            raise ValueError('Tests directory does not exist.')\n"
    "\n"            
    "        return path\n"
)

PKG_HELPERS_PY = (
    "\"\"\"\n"
    "{ProjectName} Helpers\n"
    "\n"
    "This module contains helper function definitions for the {ProjectName} application.\n"
    "\"\"\"\n"
)

PKG_UTILS_PY = (
    "\"\"\"\n"
    "{ProjectName} Utilities\n"
    "\n"
    "This module contains utility function definitions for the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "import argparse\n"
    "\n"
    "def do_something(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def do_something_else(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def do_another_thing(args: argparse.Namespace):\n"
    "    return args\n"
    "\n"
    "def preprocess_arguments(args: argparse.Namespace) -> None:\n"
    "    do_something(args)\n"
    "    do_something_else(args)\n"
    "    do_another_thing(args)\n"
    "\n"
)

PKG_MODULE_PY = (
    "\"\"\"\n"
    "{ProjectName}\n"
    "\n"
    "This module contains the class definition for the {ProjectName} class.\n"
    "\n"
    "\"\"\"\n"
    "class {ProjectName}():\n"
    "    @staticmethod\n"
    "    def subcommand1(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
    "    @staticmethod\n"
    "    def subcommand2(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
    "    @staticmethod\n"
    "    def subcommand3(*args, **kwargs):\n"
    "        print('In {packagename} -> args: ', args)\n"
    "        print('In {packagename} -> kwargs: ', kwargs)\n"
    "        return\n"
    "\n"
)

PKG_ARG_PARSER_PY = (
    "\"\"\"\n"
    "{ProjectName} Argument Parser\n"
    "\n"
    "This module contains the argument parsing functionality of the {ProjectName} application.\n"
    "\n"
    "\"\"\"\n"
    "import argparse\n"
    "from {packagename}.config import colors\n"
    "\n"
    "def create_parser():\n"
    "    parser = argparse.ArgumentParser(\n"
    "        prog='{packagename}',\n"
    "        fromfile_prefix_chars='@',\n"
    "        usage=(\n"
    "            f'{{colors.BOLD}}%(prog)s{{colors.ENDC}} '\n"
    "            f'{{colors.OKCYAN}}COMMAND{{colors.ENDC}} '\n"
    "            f'{{colors.WARNING}}[{{colors.ENDC}}OPTION{{colors.WARNING}}]{{colors.ENDC}} '\n"
    "            f'{{colors.OKBLUE}}PROJECTA{{colors.ENDC}} '\n"
    "            f'{{colors.WARNING}}[{{colors.ENDC}}{{colors.OKBLUE}}PROJECTB{{colors.ENDC}} ...{{colors.WARNING}}]{{colors.ENDC}}'\n"
    "        ),\n"
    "        formatter_class=argparse.RawDescriptionHelpFormatter,\n"
    "    )\n"
    "\n"    
    "    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')\n"
    "\n"      
    "    subparsers = parser.add_subparsers(dest='command', required=True)\n"
    "\n"
    "    subcommand_1_parser = subparsers.add_parser('subcommand1', help='subcommand1')\n"
    "    subcommand_1_parser.add_argument('-d', '--destination', type=str, help='Valid directory pathname as destination directory')\n"
    "\n"
    "    subcommand_2_parser = subparsers.add_parser('subcommand2', help='subcommand2')\n"
    "    subcommand_2_parser.add_argument('listedargs', nargs='+', type=str, help='list of args for subcommand2')\n"
    "    subcommand_2_parser.add_argument('-o', '--opt', type=str, help='modifier for subcommand2')\n"
    "\n"
    "    subcommand_3_parser = subparsers.add_parser('subcommand3', help='subcommand3')\n"
    "    subcommand_3_parser.add_argument('arg', type=str, help='arg for subcommand 3')\n"
    "    subcommand_3_parser.add_argument('-o', '--opt', type=str, help='modifier for subcommand3')\n"
    "\n"
    "    return parser\n"
)

PKG_MAIN_PY = (
    "\"\"\"\n"
    "Entry point for the {ProjectName} application.\n"
    "\n"    
    "This script serves as the main entry point for the {ProjectName} application. \n"
    "It initializes the application, processes command-line arguments, and \n"
    "starts the main functionality of the project.\n"
    "\n"
    "Usage:\n"
    "    {packagename} subcommand1 <argument> [options]\n"
    "    {packagename} subcommand2 <argument> [options]\n"
    "    {packagename} subcommand3 <argument> [options]\n"
    "\n"
    "Arguments:\n"
    "    -h, --help      Show this help message and exit.\n"
    "    -v, --version   Show the version of the application and exit.\n"
    "\n"
    "Functions:\n"
    "    main()      The main function that initializes and runs the application.\n"
    "    execute()   The function that invokes the subcommand passed to the application.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "from {packagename}.{packagename} import {ProjectName}\n"
    "from {packagename}.arg_parser import create_parser\n"
    "from {packagename}.utils import preprocess_arguments\n"
    "\n"
    "SUBCOMMANDS = {{\n"
    "    'subcommand1': {ProjectName}.subcommand1,\n"
    "    'subcommand2': {ProjectName}.subcommand2,\n"
    "    'subcommand3': {ProjectName}.subcommand3\n"
    "}}\n"
    "\n"
    "def execute(command, args):\n"
    "    func = SUBCOMMANDS[command]\n"
    "    try:\n"
    "        result = func(**vars(args))\n"
    "    except Exception as e:\n"
    "        print(f'Error: {{e}}')\n"
    "    else:\n"
    "        return result\n"
    "\n"
    "def main():\n"
    "    parser = create_parser()\n"
    "    args = parser.parse_args()\n"
    "    preprocess_arguments(args)\n"
    "    execute(args.command, args)\n"
    "\n"
)

TEST_CONFIG_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Configuration\n"
    "\n"
    "This module contains tests for the {ProjectName} configuration settings.\n"
    "\n"
    "\"\"\"\n"
    "\n"
    "import pytest\n"
    "from {packagename}.config import Config\n"
    "\n"
    "sample_config = \"\"\"\n"
    "collection:\n"
    "  VAR1: value1\n"
    "  VAR2: value2\n"
    "\"\"\"\n"
    "\n"
    "@pytest.fixture(scope='module')\n"
    "def config_file(tmp_path_factory):\n"
    "    config_path = tmp_path_factory.mktemp('data') / 'config.yaml'\n"
    "    with open(config_path, 'w') as f:\n"
    "        f.write(sample_config)\n"
    "    return config_path\n"
    "\n"    
    "def test_load_from_file(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('collection.VAR1') == 'value1'\n"
    "    assert config.get('collection.VAR2') == 'value2'\n"
    "\n"
    "def test_get_existing_key(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('collection.VAR1') == 'value1'\n"
    "\n"
    "def test_get_non_existing_key(config_file):\n"
    "    config = Config(config_file)\n"
    "    assert config.get('non.existing.key') is None\n"
    "    assert config.get('non.existing.key', 'default_value') == 'default_value'\n"
    "\n"
    "def test_add_setting(config_file):\n"
    "    config = Config(config_file)\n"
    "    config.add_setting('new_setting', key1='value1', key2='value2')\n"
    "    assert config.get('new_setting.key1') == 'value1'\n"
    "    assert config.get('new_setting.key2') == 'value2'\n"
    "\n"
    "def test_update_setting(config_file):\n"
    "    config = Config(config_file)\n"
    "    config.add_setting('update_setting', key1='value1')\n"
    "    config.update_setting('update_setting', key1='new_value', key2='value2')\n"
    "    assert config.get('update_setting.key1') == 'new_value'\n"
    "    assert config.get('update_setting.key2') == 'value2'\n"
)

TEST_HELPERS_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Helpers\n"
    "\n"
    "This module contains tests for the {ProjectName} helper functions.\n"
    "\n"
    "\"\"\"\n"
    "import pytest\n"
    "from {packagename}.helpers import * # Use explicit imports\n"
)

TEST_UTILS_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Utilities\n"
    "\n"
    "This module contains tests for the {ProjectName} utility functions.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "from pathlib import Path\n"
    "from argparse import Namespace\n"
    "\n"
    "import pytest\n"
    "\n"
    "from {packagename}.config import Config\n"
    "from {packagename}.utils import *\n"
    "\n"
    "@pytest.fixture(scope='function')\n"
    "def setup_and_teardown():\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "    Path(dummy_dir).mkdir(parents=True, exist_ok=True)\n"
    "\n"
    "    yield dummy_dir, config\n"
    "\n"
    "    for item in dummy_dir.iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "def test_do_something():\n"
    "    pass\n"
    "\n"
    "def test_do_something_else():\n"
    "    pass\n"
    "\n"
    "def test_do_another_thing():\n"
    "    pass\n"
    "\n"
    "def test_preprocess_arguments():\n"
    "    pass\n"
)

TEST_PACKAGE_MODULE_PY = (
    "\"\"\"\n"
    "{ProjectName} Tests\n"
    "\n"
    "This module contains tests for the {ProjectName} class.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "\n"
    "import pytest\n"
    "\n"
    "from {packagename}.config import Config\n"
    "from {packagename}.{packagename} import {ProjectName}\n"
    "\n"
    "@pytest.fixture(scope='function')\n"
    "def setup_and_teardown():\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "\n"
    "    yield dummy_dir, config\n"
    "\n"
    "    for item in dummy_dir.iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "def test_subcommand1(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand1 == True\n"
    "\n"
    "def test_subcommand2(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand2 == True\n"
    "\n"
    "def test_subcommand3(setup_and_teardown):\n"
    "    dummy_dir, config = setup_and_teardown\n"
    "    assert {ProjectName}.subcommand3 == True\n"
    "\n"
)

TEST_PKG_ARG_PARSER_PY = (
    "\"\"\"\n"
    "{ProjectName} Test Arg Parser\n"
    "\n"
    "This module contains tests for the {ProjectName} argument parser functionality.\n"
    "\n"
    "\"\"\"\n"
    "import pytest\n"
    "from {packagename}.arg_parser import create_parser\n"
    "\n"
    "def test_version_option(capsys):\n"
    "    parser = create_parser()\n"
    "    with pytest.raises(SystemExit):\n"
    "        parser.parse_args(['--version'])\n"
    "    captured = capsys.readouterr()\n"
    "    assert '{packagename} 1.0.0' in captured.out\n"
    "\n"
    "def test_subcommand1():\n"
    "    parser = create_parser()\n"
    "    args = parser.parse_args(['subcommand1', '--destination', 'some/directory'])\n"
    "    assert args.command == 'subcommand1'\n"
    "    assert args.destination == 'some/directory'\n"
    "\n"
    "def test_subcommand2():\n"
    "    parser = create_parser()\n"
    "    args = parser.parse_args(['subcommand2', 'arg1', 'arg2', '--opt', 'optval'])\n"
    "    assert args.command == 'subcommand2'\n"
    "    assert args.listedargs == ['arg1', 'arg2']\n"
    "    assert args.opt == 'optval'\n"
    "\n"
    "def test_subcommand3():\n"
    "    parser = create_parser()\n"
    "    args = parser.parse_args(['subcommand3', 'arg1', '--opt', 'optval'])\n"
    "    assert args.command == 'subcommand3'\n"
    "    assert args.arg == 'arg1'\n"
    "    assert args.opt == 'optval'\n"
)

TEST_CLI_PY = (
    "\"\"\"\n"
    "{ProjectName} Test CLI\n"
    "\n"
    "This module contains tests for the {ProjectName} CLI.\n"
    "\n"
    "\"\"\"\n"
    "import shutil\n"
    "import subprocess\n"
    "from pathlib import Path\n"
    "\n"
    "import pytest\n"
    "\n"
    "from {packagename}.config import Config\n"
    "\n"
    "@pytest.fixture(scope='function', autouse=True)\n"
    "def setup_and_teardown():\n"
    "    # Setup: Ensure the test directory exists\n"
    "    config = Config()\n"
    "    dummy_dir = config.get_tests_directory_path()\n"
    "    Path(dummy_dir).mkdir(parents=True, exist_ok=True)\n"
    "\n"        
    "    yield dummy_dir\n"
    "\n"        
    "    # Teardown: Clean up the test directory\n"
    "    for item in Path(dummy_dir).iterdir():\n"
    "        if item.is_dir():\n"
    "            shutil.rmtree(item)\n"
    "        else:\n"
    "            item.unlink()\n"
    "\n"
    "REASON = 'Skipping for now. Assumes application is not installed.'\n"
    "@pytest.mark.skip(reason=REASON)\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_cli_help(script_runner):\n"
    "    result = script_runner.run(['{packagename}', '--help'])\n"
    "    assert result.success\n"
    "    assert 'usage' in result.stdout\n"
    "    assert result.stderr == ''\n"
    "\n"
    "@pytest.mark.skip(reason=REASON)\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_cli_version(script_runner):\n"
    "    result = script_runner.run(['{packagename}', '--version'])\n"
    "    assert result.success\n"
    "    assert '0.1.0' in result.stdout  # Adjust based on your actual version\n"
    "    assert result.stderr == ''\n"
    "\n"
    "@pytest.mark.skip(reason=REASON)\n"
    "@pytest.mark.script_launch_mode('subprocess')\n"
    "def test_subcommand1(script_runner, setup_and_teardown):\n"
    "    dummy_projects_dir = setup_and_teardown\n"
    "    ret = script_runner.run(['{packagename}', 'subcommand1', 'arg1', '--option1', 'optval'])\n"
    "    assert ret.success\n"    
)

PROJECT_SETUP_PY = (
    "\"\"\"\n"
    "{ProjectName} Setup\n"
    "\n"
    "This module contains the setuptools.setup() definition for the {ProjectName} program.\n"
    "\n"
    "Usage\n"
    "    pipx install --editable .\n"
    "    pipx inject {packagename} -r requirements.txt\n"
    "\"\"\"\n"
    "from setuptools import setup, find_packages\n"
    "\n"
    "with open('README.md', 'r') as fh:\n"
    "    long_description = fh.read()\n"
    "\n"
    "setup(\n"
    "    name='{ProjectName}',\n"
    "    version='0.1.0',\n"
    "    author='Emille Giddings',\n"
    "    author_email='emilledigital@gmail.com',\n"
    "    description='<description>',\n"
    "    long_description=long_description,\n"
    "    long_description_content_type='text/markdown',\n"
    "    packages=find_packages(),\n"
    "    include_package_data=True,\n"
    "    package_data={{\n"
    "        '': ['config.yaml', 'data/gitignore-python', 'data/LICENSE']\n"
    "    }},\n"
    "    entry_points={{\n"
    "        'console_scripts': ['{packagename}={packagename}.__main__:main']\n"
    "    }},\n"
    "    tests_require=['pytest'],\n"
    "    classifiers=[\n"
    "        'Programming Language :: Python :: 3',\n"
    "        'Programming Language :: Python :: 3.11',\n"
    "        'License :: OSI Approved :: MIT License',\n"
    "        'Operating System :: POSIX',\n"
    "        'Operating System :: POSIX :: Linux',\n"
    "        'Development Status :: 3 - Alpha',\n"
    "        'Intended Audience :: Developers',\n"
    "        'Topic :: Software Development :: Libraries :: Python Modules',\n"
    "        'Natural Language :: English',\n"
    "    ],\n"
    "    python_requires='>=3.11',\n"
    ")\n"
)

PROJECT_README_PY = (
    "# {ProjectName}"

)

PROJECT_MANIFEST_IN = (
    "include {packagename}/config.yaml\n"
    "include {packagename}/data/gitignore-python\n"
    "include {packagename}/data/LICENSE"
)

PROJECT_PYTEST_INI = (
    "[pytest]\n"
    "testpaths = tests/test_config.py tests/test_helpers.py tests/test_utils.py tests/test_arg_parser.py tests/test_cli.py\n"
    "addopts = --ignore=env --ignore=.venv -sv\n"
)

PROJECT_LICENSE = (
    "Copyright 2021 Emille Giddings\n"
    "\n"
    "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n"
    "\n"
    "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n"
    "\n"
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
)

PROJECT_CONFIG_YAML = (
    "settings:\n"
    "  DUMMY_DIR: tests/dummy\n"
    "  VAR2: VAL2\n"
)